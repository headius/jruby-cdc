--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: Sorts <em>enum</em> using a set of keys generated by mapping the values in <em>enum</em> through the given block.
- !ruby/struct:SM::Flow::VERB 
  body: "   %w{ apple pear fig }.sort_by {|word| word.length}\n                #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]\n"
- !ruby/struct:SM::Flow::P 
  body: The current implementation of <tt>sort_by</tt> generates an array of tuples containing the original collection element and the mapped value. This makes <tt>sort_by</tt> fairly expensive when the keysets are simple
- !ruby/struct:SM::Flow::VERB 
  body: "   require 'benchmark'\n   include Benchmark\n\n   a = (1..100000).map {rand(100000)}\n\n   bm(10) do |b|\n     b.report(&quot;Sort&quot;)    { a.sort }\n     b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }\n   end\n"
- !ruby/struct:SM::Flow::P 
  body: <em>produces:</em>
- !ruby/struct:SM::Flow::VERB 
  body: "   user     system      total        real\n   Sort        0.180000   0.000000   0.180000 (  0.175469)\n   Sort by     1.980000   0.040000   2.020000 (  2.013586)\n"
- !ruby/struct:SM::Flow::P 
  body: However, consider the case where comparing the keys is a non-trivial operation. The following code sorts some files on modification time using the basic <tt>sort</tt> method.
- !ruby/struct:SM::Flow::VERB 
  body: "   files = Dir[&quot;*&quot;]\n   sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}\n   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]\n"
- !ruby/struct:SM::Flow::P 
  body: "This sort is inefficient: it generates two new <tt>File</tt> objects during every comparison. A slightly better technique is to use the <tt>Kernel#test</tt> method to generate the modification times directly."
- !ruby/struct:SM::Flow::VERB 
  body: "   files = Dir[&quot;*&quot;]\n   sorted = files.sort { |a,b|\n     test(?M, a) &lt;=&gt; test(?M, b)\n   }\n   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]\n"
- !ruby/struct:SM::Flow::P 
  body: This still generates many unnecessary <tt>Time</tt> objects. A more efficient technique is to cache the sort keys (modification times in this case) before the sort. Perl users often call this approach a Schwartzian Transform, after Randal Schwartz. We construct a temporary array, where each element is an array containing our sort key along with the filename. We sort this array, and then extract the filename from the result.
- !ruby/struct:SM::Flow::VERB 
  body: "   sorted = Dir[&quot;*&quot;].collect { |f|\n      [test(?M, f), f]\n   }.sort.collect { |f| f[1] }\n   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]\n"
- !ruby/struct:SM::Flow::P 
  body: This is exactly what <tt>sort_by</tt> does internally.
- !ruby/struct:SM::Flow::VERB 
  body: "   sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}\n   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]\n"
full_name: Enumerable#sort_by
is_singleton: false
name: sort_by
params: |
  enum.sort_by {| obj | block }    => array

visibility: public
