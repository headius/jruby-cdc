
How JRuby differs from the original Ruby
----------------------------------------
$Id$


Speed:

    JRuby is slower than 'ruby' for many reasons. It uses real objects
    for numbers, have more memory overhead and Java is in many cases
    slower than C.
    Once JRuby gets a bytecode compiler the difference should be less
    obvious.

    (Tip: If your program is long-running, try using the '-server'
    option on your VM. Startup will be slower, but after that there
    will be a major speed increase).

Object ids and finalizers:

    JRuby doesn't guarantee that integers returned by Object#id are
    unique. This also prevents the implementation of finalizers.

Threading:

    JRuby uses Java's threads, which are usually the native threads of
    the operating system, while 'ruby' uses it's own "green" thread
    implementation.
    Because Java does not provide a pthreads-compatible threading
    library, some thread operations are simulated. When told to stop,
    sleep, wait, criticalize, or wakeup, JRuby threads' behavior will
    differ slightly from pthreads.
    Threads will also act according to the thread scheduling semantics
    of the host system rather than according to the semantics of ruby's
    internal scheduler. This can mean that new bugs will appear in
    multithreaded programs because assumptions made under ruby's thread
    scheduler do not hold under JVM threading or platform-native thread
    schedulers. In general, threads provided by JRuby will act just
    like native threads.
    
Character encoding:

    JRuby uses Java's Unicode support for strings. [Something on what
    this affects.]

